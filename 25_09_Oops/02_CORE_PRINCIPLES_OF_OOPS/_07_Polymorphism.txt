
POLYMORPHISM

Polymorphism is one of the key concepts in object-oriented programming (OOP) and refers to the ability of a single entity (like a method, operator, or object) to behave differently in different contexts. The term “polymorphism” is derived from Greek, meaning “many forms.” In programming, it allows the same method or object to perform different tasks depending on the context.

There are two main types of polymorphism in Java:
    
    • Compile-Time Polymorphism (Static Polymorphism)
    
    • Run-Time Polymorphism (Dynamic Polymorphism)



1. COMPILE-TIME POLYMORPHISM (STATIC POLYMORPHISM)

In compile-time polymorphism, the method to be called is resolved at compile time. When we say the method is "resolved" at compile-time, it means that the compiler determines the correct method to invoke based on the method's signature (such as method name, parameters, etc.). It is achieved through method overloading or operator overloading (not supported in Java).

        import java.util.*;
        // Calculator Class
        class Calculator {
            // Method to add two integers
            int add(int a, int b) {
                return a + b;
            }
            
            // Method to add two decimal values
            double add(double a, double b) {
                return a + b;
            }
        }

        // Main class
        class Main {
            public static void main(String[] args) {
                Calculator calc = new Calculator();
                
                // Method resolution happens here based on the argument types (int vs double)
                System.out.println(calc.add(5, 3));          // Calls int version
                System.out.println(calc.add(5.5, 3.3));      // Calls double version
            }
        }

In this case, the compiler determines whether to call add(int, int) or add(double, double) at compile-time based on the types of arguments passed.


Keypoints:

    • Determined at compile-time.

    • Faster execution since the binding is done early.

    • Examples: Method Overloading.
    
Note that the return type cannot be a differentiator for Method Overloading.



2. RUN-TIME POLYMORPHISM (DYNAMIC POLYMORPHISM)

In run-time polymorphism, the method is resolved during the runtime. It is achieved through method overriding. When we say the method is "resolved" at run-time, it refers to the decision about which method (in the case of method overriding) to call being made at the time the program is actually running. This occurs due to the dynamic method dispatch mechanism, where the JVM decides which method of a subclass to call based on the actual object type (not the reference type) at runtime.

        import java.util.*;
        // Parent class
        class Animal {
            void sound() {
                System.out.println("Animal makes a sound");
            }
        }

        // Child class
        class Dog extends Animal {
            @Override
            void sound() {
                System.out.println("Dog barks");
            }
        }
            
            
        // Main class
        class Main {
            public static void main(String[] args) {
                Animal myAnimal = new Dog();  // Animal reference but Dog object
                
                // Method resolution happens here at runtime based on the object type (Dog)
                myAnimal.sound();  // Calls Dog's sound() method at runtime
            }
        }


Here, the method to be executed is decided at runtime based on the object type.


Keypoints:

    • Determined at runtime.
    
    • Slower execution compared to compile-time polymorphism due to late binding.
    
    • Examples: Method Overriding.



1. Static Methods and `super`

Static methods in a parent class cannot be called using super.methodName() and cannot be Overridden

They must be called directly using the class name:

    Parent.method1();  // Correct
    super.method1();   // ❌ Not allowed


2. Java Compilation and Execution Process

AT COMPILING 

    java source code ----> Syntax Check ----> Static Binding -----> ByteCode by Java Compiler 

AT RUNTIME

    ByteCode exeted by JVM ----> Class Loading ----->JIT (ByteCode to Native Machine COde of Hardware) --->Dynamic Binding -------> Program Execution -----------> Memory Mangement


3. Compile-Time vs Run-Time Polymorphism

             Mechanism      | Compile-Time Polymorphism |  Run-Time Polymorphism
    ------------------------|---------------------------|-----------------------
    Mechanism               |  Method Overloading       |  Method Overriding
    Determination           |  Resolved at Compile Time |  Resolved at Run Time
    Binding                 |  Static Binding           |  Dynamic Binding
    Inheritance             |  Not required             |  Required


Keypoints:

- Compile-Time Polymorphism → achieved through method overloading
- Run-Time Polymorphism → achieved through method overriding
- Static binding occurs at compile time, dynamic binding occurs at runtime











































