
INNER CLASSES

Inner classes are classes that are defined within another class. They are a powerful feature in Java that allows you to logically group classes that are only used in one place, making the code more readable and encapsulated. They have direct access to all the members (both static and non-static) of the outer class.

Java provides several types of inner classes to suit different use cases. These are:

    • Static Nested Classes

    • Non-Static Inner Classes

    • Local Inner Classes

    • Anonymous Inner Classes



1. STATIC NESTED CLASSES

A static nested class is defined with the static modifier. Since it is static, it does not require an instance of the outer class to be created. Static nested classes can only access the static members of the outer class.
Consider the code snippet:

        import java.util.*;
        class OuterClass {
                static int staticVar = 100;
                
                // Static Nested Class
                static class StaticNestedClass {
                    void display() {
                        System.out.println("Static variable: " + staticVar);
                    }
                }
            }
            
            // Main class
            class Main {
                public static void main(String[] args) {
                    OuterClass.StaticNestedClass nestedObj = new OuterClass.StaticNestedClass();
                    nestedObj.display(); // Output: Static variable: 100
                }
            }


Here, the StaticNestedClass can access the OuterClass's static members directly without requiring an instance of the outer class.


Keypoints:
    
    • Declared using the static keyword.
    
    • Can only access the static members of the outer class.
    
    • No reference to an outer class instance is maintained.

Static nested classes are often used to group classes that are tightly related and do not need access to instance-specific data.



2. NON-STATIC INNER CLASSES

A non-static inner class is associated with an instance of the outer class. It has access to all members (both static and non-static) of the outer class, including private members.
Consider the given code snippet:

        import java.util.*;
        class OuterClass {
            int instanceVar = 42;
            
            // Non-static Nested Inner class
            class InnerClass {
                void display() {
                    System.out.println("Instance variable: " + instanceVar);
                }
            }
        }

        class Main {
            public static void main(String[] args) {
                OuterClass outerObj = new OuterClass();
                OuterClass.InnerClass innerObj = outerObj.new InnerClass();
                innerObj.display(); // Output: Instance variable: 42
            }
        }

In the example, the InnerClass can access instanceVar directly because it is tied to an instance of OuterClass.


Keypoints:

    • Declared without the static keyword.
    • Requires an instance of the outer class to be instantiated.
    • Can access all members of the outer class.

Non-static inner classes are used when you need access to instance-specific data of the outer class.



LOCAL INNER CLASSES

Local inner classes are defined within a method or a block of code. They are only accessible within the scope of that method or block. Local inner classes can access all members of the outer class but can only access the effectively final local variables of the enclosing method.
Consider the code snippet given below:

        import java.util.*;
        class OuterClass {
            void outerMethod() {
                int localVar = 10; // Effectively final
                
                // class defined inside a method
                class LocalInnerClass {
                    void display() {
                        System.out.println("Local variable: " + localVar);
                    }
                }

                LocalInnerClass localInner = new LocalInnerClass();
                localInner.display(); // Output: Local variable: 10
            }
        }

        // Main Class
        class Main {
            public static void main(String[] args) {
                OuterClass outerObj = new OuterClass();
                outerObj.outerMethod();
            }
        }

In the example, LocalInnerClass accesses the localVar because it is effectively final.


Keypoints:
    
    • Defined within a method or block.
    
    • Can access all members of the outer class.
    
    • Can only access effectively final local variables of the enclosing method.

Local inner classes are useful for encapsulating logic within a method.



ANONYMOUS INNER CLASSES

        import java.util.*;
        abstract class Greeting {
            abstract void sayHello();
        }

        class Main {
            public static void main(String[] args) {
                Greeting greeting = new Greeting() { // Anonymous inner class
                    void sayHello() {
                        System.out.println("Hello, World!");
                    }
                };

                greeting.sayHello(); // Output: Hello, World!
            }
        }

In the example, an instance of the Greeting class is created with an overridden sayHello() method, allowing custom behavior without explicitly defining a new class.


Keypoints:
    
    • Do not have a name.
    
    • Are instantiated at the point of declaration.
    
    • Typically used when a class is needed only once.

Anonymous inner classes are commonly used in GUI applications or when implementing event listeners.


















































