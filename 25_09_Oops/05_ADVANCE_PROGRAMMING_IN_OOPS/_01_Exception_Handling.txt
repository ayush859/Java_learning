
EXCEPTION HANDLING

Exception handling is a mechanism in Java that helps manage runtime errors and maintain the normal flow of a program. An exception is an unwanted or unexpected event that occurs during program execution, disrupting the normal flow. Java provides a robust exception handling framework to catch and handle such situations efficiently.

Consider the following example (If you run the program, it will crash without exception handling):

        import java.util.*;
        // Main class
        class Main {
            public static void main(String[] args) {
                int num1 = 10, num2 = 0;
                
                // This will cause ArithmeticException (division by zero)
                int result = num1 / num2; // Program crashes 
                
                System.out.println("Result: " + result);
            }
        }

The program crashes, and the remaining code (if any) won't execute.



IMPORTANCE OF EXCEPTION HANDLING

Exception handling is essential for several reasons:
   
    • Prevents crashes: Ensures that a single error doesn't stop the entire program.
   
    • Improves debugging: Helps in identifying and resolving errors quickly.
   
    • Encapsulates error handling: Separates normal code from error-handling code.
   
    • Ensures proper resource management: Prevents memory leaks by ensuring files and connections are properly closed.

Consider the following example (with Exception Handling):

        import java.util.*;
        // Main class
        class Main {
            public static void main(String[] args) {
                int num1 = 10, num2 = 0;
                
                // Exception handling
                try {
                    int result = num1 / num2; // Risky code
                    System.out.println("Result: " + result);
                } 
                catch (ArithmeticException e) {
                    System.out.println("Error: Division by zero is not allowed!");
                }
                
                // Remaining code 
                System.out.println("Program continues...");
            }
        }
 

The program does not crash and continues execution



MECHANISM TO HANDLE EXCEPTION (TRY - CATCH BLOCK )

Java provides the try-catch mechanism to handle exceptions.
    
    • try block: Contains the code that may throw an exception.
    
    • catch block: Handles the exception if it occurs.

Syntax:

        import java.util.*;
        try {
            // Code that might cause an exception
        } 
        catch (ExceptionType e) {
            // Code to handle the exception
        }

Consider the following example:

        import java.util.*;
        class Main {
            public static void main(String[] args) {
                
                // Try-Catch Block for Exception Handling
                try {
                    int[] arr = {1, 2, 3};
                    System.out.println(arr[5]); // ArrayIndexOutOfBoundsException
                    int result = 10 / 0; // ArithmeticException
                } 
                // Catch block to handle ArrayIndexOutOfBoundsException
                catch (ArrayIndexOutOfBoundsException e) {
                    System.out.println("Error: Array index out of bounds!");
                } 
                // Catch block to handle ArithmeticException
                catch (ArithmeticException e) {
                    System.out.println("Error: Division by zero is not allowed!");
                }
                
                // Remaining code
                System.out.println("Program continues...");
            }
        }


The first exception that occurs is caught, and the program continues.


Important
    
    • Multiple catch blocks (with each catch block handling different exceptions) can be added as shown in the above example. However, Java does not allow multiple catch block of the same exception type within try-catch block.
    
    • Try-catch blocks can be nested.


finally Block (closing Resources)

The finally block is always executed, whether an exception occurs or not. It is used to close resources such as files, database connections, or network sockets. However, it is not necessary to add the finally block in the try-catch ladder.

Consider the following example:

        import java.util.*;
        // Main class
        class Main {
            public static void main(String[] args) {
                
                // Try-catch ladder
                try {
                    int result = 10 / 2;
                    System.out.println("Result: " + result);
                } 
                catch (Exception e) {
                    System.out.println("An error occurred.");
                } 
                // finally block 
                finally {
                    System.out.println("Finally block executed.");
                }
                
                System.out.println("Program continues...");
            }
        }

The finally block executes no matter what.



THROW AND THROWS KEYBOARD

Java provides two important keywords — throw and throws — for handling exceptions effectively. While they might sound similar, they serve different purposes in exception handling.



1. THROW -  MANUALLY THROWING AN EXCEPTION
    
    • The throw keyword is used inside a method or block to explicitly throw an exception.
    
    • It is typically used when we want to indicate that an error has occurred due to invalid input or some exceptional condition.
    
    • The throw statement is followed by an instance of an exception.

Syntax:

        import java.util.*;
        throw new ExceptionType("Error Message");


Note that The ExceptionType must be a subclass of Throwable (like ArithmeticException, NullPointerException, or a user-defined exception).

Let's consider an example where we prevent a person from voting if their age is below 18:

        import java.util.*;
        // Main class
        class Main {
            
            // Method to Check Age
            public static void checkAge(int age) {
                if (age < 18) {
                    // Throwing an exception
                    throw new Exception("Not eligible to vote."); 
                } 
                else {
                    System.out.println("Eligible to vote.");
                }
            }

            // Main method
            public static void main(String[] args) {
                checkAge(15); // Throws an exception
            }
        }

Explanation:

    • When checkAge(15) is called, the method detects that the age is less than 18.

    • The throw keyword manually raises an ArithmeticException.

    • Since there is no try-catch block, the program terminates abruptly.



2. THROWS - DECLARING AN  EXCEPTION 
    
    • The throws keyword is used in a method signature to indicate that the method might throw an exception.
    
    • It does not handle the exception but forces the caller to handle it.
    
    • This is useful when a method relies on external resources like files, databases, or network connections.

Syntax:

        import java.util.*;
        returnType methodName() throws ExceptionType {
            // Method code that might throw an exception
        }


The method does not handle the exception internally; it leaves the responsibility to the caller.

Let's consider a method that performs division but might cause an ArithmeticException:

        import java.util.*;
        // Main class
        class Main {
                static void divide() throws ArithmeticException { // Declaring an exception
                    int result = 10 / 0; // Risky code (division by zero)
                }
                
                public static void main(String[] args) {
                    // Try-catch ladder
                    try {
                        divide(); // Calling the method that might throw an exception
                    } 
                    // Catch block to handle ArithmeticException 
                    catch (ArithmeticException e) {
                        System.out.println("Handled exception: " + e);
                    }
                    
                    System.out.println("Program continues...");
                }
            }


Explanation:
    
    • The divide() method declares that it might throw an ArithmeticException using throws keyword.
    
    • The main() method calls divide(), so it must handle the exception using try-catch.
    
    • When division by zero occurs, the exception is caught and handled without stopping the program.


    
KEY DIFFERENCES BETWEEEN THROW AND THROWS


+-------------------------+---------------------------------------------------------------+---------------------------------------------------------------+
|         Feature         |                            throw                              |                            throws                             |
+-------------------------+---------------------------------------------------------------+---------------------------------------------------------------+
|         Purpose         | Used to explicitly throw an exception inside a method.        | Used to declare that a method might throw an exception.       |
+-------------------------+---------------------------------------------------------------+---------------------------------------------------------------+
|          Usage          | Inside a method or block.                                     | In the method signature.                                      |
+-------------------------+---------------------------------------------------------------+---------------------------------------------------------------+
|   Exception Handling    | Throws a specific exception immediately.                      | Does not handle exceptions; just declares them.               |
+-------------------------+---------------------------------------------------------------+---------------------------------------------------------------+
|  Number of Exceptions   | Can throw only one exception at a time.                       | Can declare multiple exceptions (comma-separated).            |
+-------------------------+---------------------------------------------------------------+---------------------------------------------------------------+
|         Example         | throw new NullPointerException("Null value found");           | void myMethod() throws IOException, SQLException {}           |
+-------------------------+---------------------------------------------------------------+---------------------------------------------------------------+



CUSTOM EXCEPTION

In Java, custom exceptions (also known as user-defined exceptions) allow developers to define their own exception classes. This is useful when the built-in Java exceptions (ArithmeticException, IOException, etc.) do not fully describe the error conditions specific to an application.
By creating a custom exception, we can provide more meaningful error messages and handle specific cases more effectively.

Let's understand this with the following example:

        import java.util.*;
        // Custom Exception class 
        class CustomException extends Exception { 
            // Constructor 
            CustomException(String message) {
                super(message);
            }
        }

        // Main class
        class Main {
            public static void main(String[] args) {
                
                // try-catch ladder
                try {
                    // throwing custom made exception
                    throw new CustomException("This is a custom exception!");
                } 
                catch (CustomException e) {
                    System.out.println("Caught: " + e.getMessage());
                }
                
                System.out.println("Program continues...");
            }
        }

It is useful when the need is to define application-specific errors.



REAL LIFE EXAMPLE OF EXCEPTION HANDLING

In real-world applications, exceptions frequently occur due to external dependencies, such as file handling, database access, or network communication. Proper exception handling ensures that the program does not crash and provides a meaningful error message to the user.

Say in our program, one needs to read the content of other file (that may not exist). In such cases, file handling exception must be implemented properly.

        import java.util.*;
        import java.io.File;
        import java.io.FileNotFoundException;
        import java.util.Scanner;

        // Main class
        class Main {
            public static void main(String[] args) {
                try {
                    // Trying to read a file that does not exist
                    File file = new File("nonexistent.txt");
                    
                    Scanner reader = new Scanner(file); // FileNotFoundException may occur
                } 
                catch (FileNotFoundException e) {
                    System.out.println("Error: File not found!");
                }
                
                System.out.println("Program continues...");
            }
        }



CHECKED AND UNCHECKED EXCEPTION

checked Exceptions:

These are exceptions that the compiler forces you to handle using try-catch or declare using throws (e.g., IOException, SQLException).

        import java.util.*;
        import java.io.File;
        import java.io.FileNotFoundException;
        import java.util.Scanner;

        // Main class
        class Main {
            public static void main(String[] args) throws FileNotFoundException { 
                File file = new File("test.txt");
                Scanner reader = new Scanner(file); // Must handle or declare exception
            }
        }

Must be handled using try-catch or declared using throws.


Unchecked Exceptions:

These occur at runtime and do not require explicit handling. They are usually due to logical errors in the code (e.g., NullPointerException, ArithmeticException).
Example:

        import java.util.*;
        public class UncheckedExceptionExample {
            public static void main(String[] args) {
                int result = 10 / 0; // ArithmeticException (unchecked)
            }
        }

Occurs at runtime, no compilation error.










































































































































































































