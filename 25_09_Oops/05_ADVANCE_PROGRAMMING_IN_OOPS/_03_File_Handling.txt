
FILE HANDLING IN OOPS 


File handling refers to the process of reading from and writing to files to store and retrieve data in a persistent manner. It allows programs to interact with files stored on disk, enabling long-term data storage and retrieval.

There are various operations involved in File Handling, some of which are:

    • Creating a file

    • Reading from a file

    • Writing to a file

    • Appending data to a file

    • Deleting a file

Example: Creating a File

Java provides the File class from the java.io package to handle file operations.

        import java.util.*;
        import java.io.File;
        import java.io.IOException;

        class Main {
            public static void main(String[] args) {
                try {
                    File file = new File("example.txt");
                    if (file.createNewFile()) {
                        System.out.println("File created: " + file.getName());
                    } else {
                        System.out.println("File already exists.");
                    }
                } catch (IOException e) {
                    System.out.println("An error occurred.");
                    e.printStackTrace();
                }
            }
        }

Here, try-catch block is used to handle the potential IOException from the createNewFile(). The createNewFile() method in Java throws an IOException if an error occurs while creating the file (e.g., insufficient permissions, invalid file path, or disk-related issues).



IMPORTANCE OF FILE HANDLING IN OOPS

File handling is crucial in object-oriented programming (OOPs) because it provides mechanisms for:

    • Logging: Storing logs for debugging and monitoring.

    • Configuration Management: Reading and writing configuration settings from files.

    • Data Storage: Storing user-generated content, records, or database backups.



FILE CLASS

The File class in Java provides various methods to manipulate files and directories. Some of the commonly used methods are:

    • createNewFile(): Creates a new empty file.

    • exists(): Checks if a file exists.

    • delete(): Deletes a file.

    • getAbsolutePath(): Returns the file's absolute path.

    • length(): Returns the size of the file in bytes.

    • canRead(), canWrite(): Checks file permissions.

Example: Checking File Properties

        import java.util.*;
        import java.io.File;

        // Main class
        class Main {
            public static void main(String[] args) {
                File file = new File("example.txt"); 
                
                if (file.exists()) {
                    System.out.println("File Name: " + file.getName());
                    System.out.println("Absolute Path: " + file.getAbsolutePath());
                    System.out.println("Writable: " + file.canWrite());
                    System.out.println("Readable: " + file.canRead());
                    System.out.println("File Size in bytes: " + file.length());
                } else {
                    System.out.println("The file does not exist.");
                }
            }
        }



FILE WRITER AND BUFFER WRITER

The FileWriter class is used to write character-based data to a file, and BufferedWriter improves efficiency by buffering large amounts of data before writing.

Example: Writing Data using BufferedWriter

        import java.util.*;
        import java.io.BufferedWriter;
        import java.io.FileWriter;
        import java.io.IOException;

        // Main class
        class Main {
            public static void main(String[] args) {
                BufferedWriter writer = null;
                
                // Try-catch block to handle exception
                try {
                    writer = new BufferedWriter(new FileWriter("output.txt"));
                    
                    // Writing in the file 
                    writer.write("Hello, world!\n");
                    writer.write("This is a sample file.");
                    
                    // Closing the file after writing
                    writer.close();
                    System.out.println("File written successfully.");
                } catch (IOException e) {
                    e.printStackTrace(); 
                }
                
                // Remaining section of the code 
            }
        }


FILE READER AND BUFFER READER

The FileReader class is used to read data from a file as a stream of characters, while BufferedReader improves efficiency by reading large chunks of data at once.

Example: Reading a File Using BufferedReader

        import java.util.*;
        import java.io.BufferedReader;
        import java.io.FileReader;
        import java.io.IOException;

        // Main class
        class Main {
            public static void main(String[] args) {
                
                BufferedReader reader = null;
                
                // try-catch block to handle the exception 
                try {
                    reader = new BufferedReader(new FileReader("example.txt"));
                    String line;
                    
                    int i = 1;
                    
                    // Read each line until nothing is left 
                    while((line = reader.readLine()) != null) {
                        System.out.println("Line " + i + ": " + line);
                        i++;
                    }
                    
                    reader.close(); //Close the file after reading
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }



TRY - WITH - RESOURCES 

The try-with-resources statement automatically closes the file resource after execution, ensuring proper resource management. This eliminates the chances of missing closing any file used in the codebase preventing resource leakage.

The try-with-resource is nothing but a try block with the resources declared in its arguments.

Example: Using Try-with-Resources for File Reading

        import java.util.*;
        import java.io.BufferedReader;
        import java.io.FileReader;
        import java.io.IOException;

        // Main class
        class Main {
            public static void main(String[] args) {
                
                // Try with Resources (removes the need to close the file explicitly)
                try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        System.out.println(line);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }



LOGGING APPLICATION DATA

Logging is essential for debugging and monitoring an application. The java.util.logging package provides built-in support for logging.

Example: Logging to a file

        import java.util.*;
        import java.io.*;

        // Logger class
        class Logger {
            private String path; // to store the path of file
            
            // Constructor
            Logger(String path) throws IOException {
                File file = new File(path); // Open the file path 
                
                // Create the file if it does not exist
                if (!file.exists()) {
                    file.createNewFile();
                }
                this.path = path;
            }
            
            // Log the message in the file
            public void log(String message) {
                try (BufferedWriter bw = new BufferedWriter(new FileWriter(path, true))) {
                    bw.write(message); 
                    bw.newLine();
                } catch (Exception e) {
                    System.out.println("Failed to log this message " + message);
                }
            }
        }

        // Main class
        class Main {
            public static void main(String[] args) {
                try {
                    // Create a Logger instance with a specified log file path
                    Logger myLogger = new Logger("application.log");

                    // Log some messages
                    myLogger.log("Application started...");
                    myLogger.log("User logged in.");
                    myLogger.log("Error: Unable to connect to the database.");
                    myLogger.log("Application closed.");

                    System.out.println("Logs have been written successfully.");
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }


Code Breakdown:
 
    • Instance Variable: private String path; → Stores the file path where logs will be written.
    
    • Constructor (Logger(String path)):
    
        • Takes the log file path as a parameter.
    
        • Uses the File class to check if the file exists. If not, it creates a new file.
    
        • Initializes the path variable with the given file path.
    
    • log(String message) Method:
    
        • Uses BufferedWriter and FileWriter to write messages to the log file.
    
        • The second argument true in FileWriter(path, true) enables appending mode, ensuring logs are added instead of overwriting the file.
    
        • Writes the message to the file and adds a new line (newLine()).
    
        • Handles exceptions and prints a failure message if writing fails.
    
The above code provides a simple example of Logger class. You can build a more feature-rich (timestamps, data information, etc.) Logger class as per your convenience using Java's built-in java.util.logging package.



COMMON FILE HANDLING ISSUES

There are several issues that can arise while handling files, such as:

    • FileNotFoundException: Occurs when the specified file does not exist. It can be avoided by checking if the file exists before attempting to read it.

    • IOException: Occurs due to issues like permission restrictions, insufficient disk space, or network failure. It can be handled using try-catch blocks.

    • Resource Leaks: Forgetting to close file streams can lead to memory leaks. To avoid this, the best practice is to use try-with-resources to automatically close resources.



















































































































