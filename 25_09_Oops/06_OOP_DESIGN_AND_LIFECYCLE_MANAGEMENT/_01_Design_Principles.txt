
SOLID PRINCIPLES IN OBJECT-ORIENTED PROGRAMMING

The SOLID principles are a set of five design guidelines introduced by Robert C. Martin to enhance the maintainability, scalability, and robustness of object-oriented software. These principles help developers create code that is more modular, flexible, and easier to understand. Let's go through each principle in detail.



1) SINGLE RESPONSIBILITY PRINCIPLE (SRP)

Definition:

A class should have only one reason to change, meaning it should have only a single responsibility.

Explanation:

This principle states that a class should focus on only one functionality. If a class is handling multiple responsibilities, it becomes difficult to maintain and update, leading to unintended side effects. By adhering to SRP, we ensure that changes in one part of the system do not affect unrelated functionalities.

Example:

Consider the following example where a class that both calculates employee salary and generates reports. Instead, these responsibilities should be split into separate classes:

        import java.util.*;
        class SalaryCalculator {
            public double calculateSalary(Employee emp) {
                // Salary calculation logic
            }
        }

        class ReportGenerator {
            public void generateReport(Employee emp) {
                // Report generation logic
            }
        }


Now, changes in salary calculation do not affect report generation.

Use Case: If we need to modify salary calculation, we only update SalaryCalculator, avoiding unintended issues in report generation.



2) OPEN/CLOSED PRINCIPLE (OCP)

Definition:

A class should be open for extension but closed for modification.

Explanation:

This means that we should be able to add new functionality to a class without modifying its existing code. This is achieved using abstraction and polymorphism (e.g., interfaces and inheritance).

Example:

Consider an example where the aim is to calculate the area.

A naive approach will be to form different classes for each shape in the following way:

        import java.util.*;
        class Rectangle {
            public double calculateArea() { return length * breadth; }
        }

        class Circle {
            public double calculateArea() { return Math.PI * radius * radius; }
        }

A better approach is using polymorphism:

        import java.util.*;
        abstract class Shape {
            abstract double calculateArea();
        }

        class Rectangle extends Shape {
            double calculateArea() { return length * breadth; }
        }

        class Circle extends Shape {
            double calculateArea() { return Math.PI * radius * radius; }
        }

Now, if we want to add a Triangle class, we don't need to modify existing code—just extend Shape.

Use Case: Adding new shapes without modifying existing classes.



3) LISKOV SUBSTITUTION PRINCIPLE (LSP)

Definition:

Subtypes should be substitutable for their base types without altering the correctness of the program.

Explanation:

This principle ensures that derived classes extend base classes without changing their behavior. If a subclass changes how the base class behaves unexpectedly, it breaks the system.

Example (Violation of LSP):

Imagine a Bird class with a method fly(). If we create a subclass Penguin that cannot fly, we break LSP:

        import java.util.*;
        class Bird {
            public void fly() { System.out.println("Flying"); }
        }

        class Penguin extends Bird {
            public void fly() { throw new UnsupportedOperationException("Penguins can't fly!"); }
        }

Instead, we should refactor using separate interfaces:

        import java.util.*;
        interface FlyingBird {
            void fly();
        }

        class Sparrow implements FlyingBird {
            public void fly() { System.out.println("Flying high!"); }
        }

        class Penguin { 
            // Penguins do not implement FlyingBird
        }

Now, LSP is preserved because no subclass breaks expected behavior.

Use Case: Preventing unexpected crashes when substituting subclasses.



4) INTERFACE SEGREGATION PRINCIPLE (ISP)

Definition:

A class should not be forced to implement interfaces it does not use.

Explanation:

Rather than having large, monolithic interfaces, we should have smaller, more specific ones. This prevents unnecessary method implementations in classes that don't need them.

Example (Violation of ISP):

A large interface forces unnecessary method implementation:

        import java.util.*;
        interface Worker {
            void work();
            void eat();
        }

        class Robot implements Worker {
            public void work() { System.out.println("Robot working"); }
            public void eat() { throw new UnsupportedOperationException("Robots don't eat!"); }
        }


A better approach is splitting into separate interfaces:

        import java.util.*;
        interface Workable {
            void work();
        }

        interface Eatable {
            void eat();
        }

        class Human implements Workable, Eatable {
            public void work() { System.out.println("Human working"); }
            public void eat() { System.out.println("Human eating"); }
        }

        class Robot implements Workable {
            public void work() { System.out.println("Robot working"); }
        }

Now, Robot doesn't need to implement eat().

Use Case: Avoiding unnecessary dependencies in classes.



5) DEPENDENCY INVERSION PRINCIPLE (DIP)

Definition:

High-level modules should not depend on low-level modules. Both should depend on abstractions.

Explanation:

Instead of directly depending on concrete classes, we should depend on interfaces or abstract classes. This makes the system more flexible and decoupled.

Example (Violation of DIP):

        import java.util.*;
        class WiredKeyboard {
            void connect() { System.out.println("Connected via wire."); }
        }

        class Computer {
            private WiredKeyboard keyboard = new WiredKeyboard(); // Direct dependency
        } 

A better approach is using an interface:

        import java.util.*;
        interface Keyboard {
            void connect();
        }

        class WiredKeyboard implements Keyboard {
            public void connect() { System.out.println("Connected via wire."); }
        }

        class WirelessKeyboard implements Keyboard {
            public void connect() { System.out.println("Connected via Bluetooth."); }
        }

        class Computer {
            private Keyboard keyboard;
            
            Computer(Keyboard keyboard) { this.keyboard = keyboard; }
        }

Now, we can pass any Keyboard type (wired/wireless) without modifying Computer.

Use Case: Making systems extensible and maintainable.



CONCLUSION:

The SOLID principles help in building scalable, maintainable, and flexible software.

    • SRP ensures that classes have a single responsibility.

    • OCP allows extending functionality without modifying existing code.

    • LSP ensures that subclasses do not break the behavior of base classes.

    • ISP prevents forcing classes to implement unnecessary methods.

    • DIP promotes dependency on abstractions rather than concrete implementations.

By following SOLID, we create clean, robust, and testable code that is easier to maintain and extend.


